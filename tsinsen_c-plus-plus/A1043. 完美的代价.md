# A1043. 完美的代价

[链接](http://www.tsinsen.com/A1043)

## 问题描述

回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。 

交换的定义是：交换两个相邻的字符 

例如mamad 

第一次交换 ad : mamda 

第二次交换 md : madma 

第三次交换 ma : madam (回文！完美！) 

## 输入格式

第一行是一个整数N，表示接下来的字符串的长度(N <= 8000) 

第二行是一个字符串，长度为N.只包含小写字母 

## 输出格式

如果可能，输出最少的交换次数。 

否则输出Impossible 

## 样例输入

5
mamad

## 样例输出

3

# 总结

1.  贪心思想，从左向右遍历，对于当前字符，从最右边向左遍历，找到与当前字符相同的，把它移动到正确位置，累加步数。如果字符串长度为偶数，只要有一个无法配对的字符，就不能变成回文串，若为奇数，只要出现两个无法配对的字符，也不能。
2. **看代码，有很多细节**

# 结果

---

	#include<string>
	#include<iostream>
	using namespace std;
	/*
		从前向后遍历字符串
		遍历每个字符时，从字符串末尾开始寻找符合条件的字符，并将其放在正确的位置上
	*/
	
	int main()
	{
		int size;
		string s;
		cin >> size;
		cin >> s;
	
		int step = 0;//记录最小步数
		int i = 0;//记录遍历位置
		int j = size - 1;//记录遍历位置
		
		if (size % 2 == 0)
		{
			//如果串长度为偶数
			while (i + 1 != j)
			{
				if (s[i] == s[j])
				{
					//处于正常的位置，不用动
					i++;
					j--;
				}
				else
				{
					//不处于正常的位置，需要从j向i遍历
					int k = j - 1;
					for (; k > i; k--)
					{
						if (s[k] == s[i]) break;
					}
					if (k == i)
					{
						//如果k=i说明没有找到相应的字符，因为是偶数长度串，所以直接结束
						cout << "Impossible" << endl;
						return 0;
					}
					else
					{
						//如果 k!=i 说明找到了相应的字符，需要将字符移到j的位置，增加相应步数，并调整ij位置
						char temp = s[k];
						while (k < j)
						{
							s[k] = s[k + 1];
							k++;
							step++;
							//循环结束时k=j
						}
						s[k] = temp;
						i++;
						j--;
					}
				}
			}
			//循环的结束条件是i+1=j，所以如果循环结束，最后需要判断中间两个字符是否相等
			if (s[i] != s[j])
			{
				cout << "Impossible" << endl;
				return 0;
			}
		}
	
		else
		{
			//如果串长度为奇数
			int ok = 0;//最中间位置是单独的字符，没有与之匹配的字符，所以需要一个标志位来记录
			while (i < j)//注意循环的条件是i<j而不能是i!=j，因为对于中间的字符，我们没有移动，仅仅加了步数，如果i!=j会导致 ij互相错过的情况
			{
				if (s[i] == s[j])
				{
					//处于正常的位置，不用动
					i++;
					j--;
				}
				else
				{
					//不处于正常的位置，需要从j向i遍历
					int k = j - 1;
					for (; k > i; k--)
					{
						if (s[k] == s[i]) break;
					}
					if (k == i && ok == 0)//如果k=i说明没有找到相应的字符，因为是奇数长度串，所以需要判断标志位ok的值
					{
						//当ok值为0时说明找到的中间的位置
						step = step + (size - 1) / 2 - i;
						//先不用管中间字符，记录中间字符位置后直接跳过即可，处理之后的字符串，就像处理偶数长度的串一样
						i++;
						ok = 1;//标志位
					}
					else if(k == i && ok == 1)
					{
						//如果没有找到相应字符，并且已经找到中间字符了，说明无法匹配成功
						cout << "Impossible" << endl;
						return 0;
					}
					else
					{
						//如果 k!=i 说明找到了相应的字符，需要将字符移到j的位置，增加相应步数，并调整ij位置
						char temp = s[k];
						while (k < j)
						{
							s[k] = s[k + 1];
							k++;
							step++;
							//循环结束时k=j
						}
						s[k] = temp;
						i++;
						j--;
					}
				}
			}
		}
	
		cout << step << endl;
		return 0;
	}

---
